第四周总结
第四周基本上题目类型都属于比较难的，所以我从简单题目开始刷起。
720:快速写完，代码量有点多，实现了一个修改版的trie，为什么说是修改版，因为我对传进来的word数组进行了排序，所以后面的单词肯定包含前面的单词。那我就进行个排序将前面的单词先build。
70:快速使用三种方法写完，一个回溯，一个递推，一个dp。然后把使用递归的方法通过加备忘录的方式优化了时间复杂度和空间复杂度。降低到和dp一样的O(n)。
198:快速写完，后来看了discussion，人家进一步降低了空间复杂度，用了两个变量prev1，和prev2来代表max(n-1)和max(n-2),将空间复杂度降低为O(1)。值得学习。
309:参考了reference，难点是动态转移方程的建立，这道题用到了两个动态转移数组，比较难想到，也算一种题型和思路，下次碰到类似提醒，可以想想多种状态，每种状态也有时间顺序变化，状态之间又互相影响，可以通过使用不同的动态转移数组来表示。
213:是198的变形，快速写完，但是我的代码不够简洁，我将其分为0-n-2和1-n-1两段，然后取其最大值。
62:这道题印象太深刻了，我面试的时候遇到过，直接DP写出，当然也可以用回溯用递推，很多种方法，dp是最好的方法。我面试的时候做出来了吗，答案是我做出来了，我用了两种回溯和DP，不过DP的递推公式是面试官提示的。
63:老师上课讲过类似的题型，所以也很快做出来了，这类型题目我觉得都可以通过画图的方式来解决。是同一类型套路题。区别在于有障碍的你只要将那个坐标点设置为0即可。需要注意的是注意初始化的时候dpArray[i][0]和dpArray[0][j]的值，当存在obstacle的话后续的i和j增值所在的位置都为0. 看了discussion后自己尝试了再进一步缩减空间复杂度，将空间复杂度降低为O(1).
784:使用回溯，快速做完，看了下解法有人使用bfs，尝试用bfs再解了一遍。
337:很快想到用BFS，动态转移方程是Max(n)=Math.max(Max(n-1),sum+Max(n-2))。

